use std::path::PathBuf;

use aws_sdk_s3::Client as S3Client;
use clap::Parser;
use miette::{miette, IntoDiagnostic, Result};
use tokio::{fs::File, io::AsyncReadExt};
use tracing::{info, instrument};

use crate::{
	actions::{upload::token::decode_token, Context},
	aws,
};

use super::UploadArgs;

/// Confirm an upload.
///
/// Given a pre-auth token or Upload ID (as generated by `bestool upload preauth`), confirm it. This
/// will finalise the upload and write the file to the bucket. Until this is called, the upload is
/// not visible to the bucket and will eventually get deleted.
///
/// This MUST be run from your local, trusted computer, using WriteAccess or AdminAccess to the
/// account that contains the destination bucket. Make sure the upload is complete before calling
/// this, as it may fail or write a partial file otherwise.
#[derive(Debug, Clone, Parser)]
pub struct ConfirmArgs {
	/// File which contains the token to confirm.
	#[arg(long, value_name = "FILENAME", default_value = "token.txt", required_unless_present_any = &["token", "upload_id"])]
	pub token_file: PathBuf,

	/// Token value.
	///
	/// This is the token to confirm. If not specified here, it will be taken from the file specified
	/// in `--token-file`. Prefer to use `--token-file` instead of this option, as tokens are
	/// generally larger than can be passed on the command line.
	#[arg(long, value_name = "TOKEN")]
	pub token: Option<String>,

	/// Upload ID.
	///
	/// This is the Upload ID to confirm. If not specified here, it will be taken from `--token` or
	/// `--token-file`.
	#[arg(long, value_name = "UPLOAD_ID", conflicts_with_all = &["token", "token_file"])]
	pub upload_id: Option<String>,

	/// AWS Access Key ID.
	///
	/// This is the AWS Access Key ID to use for authentication. If not specified here, it will be
	/// taken from the environment variable `AWS_ACCESS_KEY_ID`, or from the AWS credentials file
	/// (usually `~/.aws/credentials`), or from ambient credentials (eg EC2 instance profile).
	#[arg(long, value_name = "KEY_ID")]
	pub aws_access_key_id: Option<String>,

	/// AWS Secret Access Key.
	///
	/// This is the AWS Secret Access Key to use for authentication. If not specified here, it will
	/// be taken from the environment variable `AWS_SECRET_ACCESS_KEY`, or from the AWS credentials
	/// file (usually `~/.aws/credentials`), or from ambient credentials (eg EC2 instance profile).
	#[arg(long, value_name = "SECRET_KEY")]
	pub aws_secret_access_key: Option<String>,

	/// AWS Region.
	///
	/// This is the AWS Region to use for authentication and for the bucket. If not specified here,
	/// it will be taken from the environment variable `AWS_REGION`, or from the AWS credentials
	/// file (usually `~/.aws/credentials`), or from ambient credentials (eg EC2 instance profile).
	#[arg(long, value_name = "REGION")]
	pub aws_region: Option<String>,
}

crate::aws::standard_aws_args!(ConfirmArgs);

#[instrument(skip(ctx))]
pub async fn run(ctx: Context<UploadArgs, ConfirmArgs>) -> Result<()> {
	let id = if let Some(upload_id) = ctx.args_sub.upload_id.as_deref() {
		upload_id.parse().map_err(|err| miette!("{}", err))?
	} else {
		let token = if let Some(token) = ctx.args_sub.token.clone() {
			token
		} else {
			let mut file = File::open(&ctx.args_sub.token_file)
				.await
				.into_diagnostic()?;
			let mut token = String::new();
			file.read_to_string(&mut token).await.into_diagnostic()?;
			token
		};

		decode_token(&token)?.id
	};

	let aws = aws::init(&ctx.args_sub).await;
	let _client = S3Client::new(&aws);

	info!(?id, "Finalising multipart upload");
	// client
	// 	.abort_multipart_upload()
	// 	.bucket(id.bucket)
	// 	.key(id.key)
	// 	.upload_id(id.id)
	// 	.send()
	// 	.await
	// 	.into_diagnostic()?;

	Ok(())
}
