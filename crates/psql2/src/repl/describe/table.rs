use std::ops::ControlFlow;

use comfy_table::Table;

use crate::repl::state::ReplContext;

pub(super) async fn handle_describe_table(
	ctx: &mut ReplContext<'_>,
	schema: &str,
	table_name: &str,
	detail: bool,
	sameconn: bool,
) -> ControlFlow<()> {
	let columns_query = r#"
		SELECT
			a.attname AS column_name,
			pg_catalog.format_type(a.atttypid, a.atttypmod) AS data_type,
			CASE WHEN a.attnotnull THEN 'not null' ELSE '' END AS nullable,
			CASE
				WHEN pg_catalog.pg_get_expr(d.adbin, d.adrelid, true) IS NOT NULL
					THEN 'default ' || pg_catalog.pg_get_expr(d.adbin, d.adrelid, true)
				ELSE ''
			END AS default_value,
			CASE
				WHEN a.attidentity = 'a' THEN 'generated always as identity'
				WHEN a.attidentity = 'd' THEN 'generated by default as identity'
				ELSE ''
			END AS identity,
			CASE WHEN a.attgenerated = 's' THEN 'generated' ELSE '' END AS generated,
			pg_catalog.col_description(c.oid, a.attnum) AS description
		FROM pg_catalog.pg_class c
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
		LEFT JOIN pg_catalog.pg_attribute a ON a.attrelid = c.oid
		LEFT JOIN pg_catalog.pg_attrdef d ON d.adrelid = c.oid AND d.adnum = a.attnum
		WHERE n.nspname = $1
			AND c.relname = $2
			AND a.attnum > 0
			AND NOT a.attisdropped
		ORDER BY a.attnum
	"#;

	let indexes_query = r#"
		SELECT
			i.relname AS index_name,
			pg_catalog.pg_get_indexdef(i.oid) AS index_def,
			CASE WHEN ix.indisprimary THEN 'PRIMARY KEY'
				WHEN ix.indisunique THEN 'UNIQUE'
				ELSE ''
			END AS constraint_type,
			am.amname AS index_type
		FROM pg_catalog.pg_index ix
		LEFT JOIN pg_catalog.pg_class i ON i.oid = ix.indexrelid
		LEFT JOIN pg_catalog.pg_class c ON c.oid = ix.indrelid
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
		LEFT JOIN pg_catalog.pg_am am ON i.relam = am.oid
		WHERE n.nspname = $1
			AND c.relname = $2
		ORDER BY ix.indisprimary DESC, ix.indisunique DESC, i.relname
	"#;

	let foreign_keys_query = r#"
		SELECT
			conname AS constraint_name,
			pg_catalog.pg_get_constraintdef(oid, true) AS constraint_def
		FROM pg_catalog.pg_constraint
		WHERE conrelid = (
			SELECT c.oid
			FROM pg_catalog.pg_class c
			LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
			WHERE n.nspname = $1 AND c.relname = $2
		)
		AND contype = 'f'
		ORDER BY conname
	"#;

	let check_constraints_query = r#"
		SELECT
			conname AS constraint_name,
			pg_catalog.pg_get_constraintdef(oid, true) AS constraint_def
		FROM pg_catalog.pg_constraint
		WHERE conrelid = (
			SELECT c.oid
			FROM pg_catalog.pg_class c
			LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
			WHERE n.nspname = $1 AND c.relname = $2
		)
		AND contype = 'c'
		ORDER BY conname
	"#;

	let table_info_query = r#"
		SELECT
			pg_catalog.pg_get_userbyid(c.relowner) AS owner,
			pg_size_pretty(pg_total_relation_size(c.oid)) AS size,
			CASE c.relpersistence
				WHEN 'p' THEN 'permanent'
				WHEN 'u' THEN 'unlogged'
				WHEN 't' THEN 'temporary'
			END AS persistence,
			obj_description(c.oid, 'pg_class') AS table_comment
		FROM pg_catalog.pg_class c
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
		WHERE n.nspname = $1 AND c.relname = $2
	"#;

	let columns_result = if sameconn {
		ctx.client
			.query(columns_query, &[&schema, &table_name])
			.await
	} else {
		match ctx.pool.get().await {
			Ok(client) => client.query(columns_query, &[&schema, &table_name]).await,
			Err(e) => {
				eprintln!("Error getting connection from pool: {}", e);
				return ControlFlow::Continue(());
			}
		}
	};

	match columns_result {
		Ok(rows) => {
			if rows.is_empty() {
				eprintln!("No columns found for table \"{}.{}\".", schema, table_name);
				return ControlFlow::Continue(());
			}

			println!("Table \"{}.{}\"", schema, table_name);

			let mut table = Table::new();
			crate::table::configure(&mut table);

			if detail {
				table.set_header(vec![
					"Column",
					"Type",
					"Collation",
					"Nullable",
					"Default",
					"Description",
				]);
			} else {
				table.set_header(vec!["Column", "Type", "Collation", "Nullable", "Default"]);
			}

			for row in rows {
				let column_name: String = row.get(0);
				let data_type: String = row.get(1);
				let nullable: String = row.get(2);
				let default_value: String = row.get(3);
				let identity: String = row.get(4);
				let generated: String = row.get(5);
				let description: Option<String> = if detail { row.get(6) } else { None };

				let mut default_str = String::new();
				if !identity.is_empty() {
					default_str = identity;
				} else if !generated.is_empty() {
					default_str = generated;
				} else if !default_value.is_empty() {
					default_str = default_value;
				}

				if detail {
					table.add_row(vec![
						column_name,
						data_type,
						String::new(), // collation placeholder
						nullable,
						default_str,
						description.unwrap_or_default(),
					]);
				} else {
					table.add_row(vec![
						column_name,
						data_type,
						String::new(), // collation placeholder
						nullable,
						default_str,
					]);
				}
			}

			crate::table::style_header(&mut table);
			println!("{table}");

			let indexes_result = if sameconn {
				ctx.client
					.query(indexes_query, &[&schema, &table_name])
					.await
			} else {
				match ctx.pool.get().await {
					Ok(client) => client.query(indexes_query, &[&schema, &table_name]).await,
					Err(_) => {
						return ControlFlow::Continue(());
					}
				}
			};

			if let Ok(index_rows) = indexes_result {
				if !index_rows.is_empty() {
					println!("\nIndexes:");
					for row in index_rows {
						let index_name: String = row.get(0);
						let index_def: String = row.get(1);
						let constraint_type: String = row.get(2);

						if !constraint_type.is_empty() {
							println!(
								"    \"{}\" {} {}",
								index_name,
								constraint_type,
								&index_def[index_def.find("USING").unwrap_or(0)..]
							);
						} else {
							println!(
								"    \"{}\" {}",
								index_name,
								&index_def[index_def.find("USING").unwrap_or(0)..]
							);
						}
					}
				}
			}

			let fk_result = if sameconn {
				ctx.client
					.query(foreign_keys_query, &[&schema, &table_name])
					.await
			} else {
				match ctx.pool.get().await {
					Ok(client) => {
						client
							.query(foreign_keys_query, &[&schema, &table_name])
							.await
					}
					Err(_) => {
						return ControlFlow::Continue(());
					}
				}
			};

			if let Ok(fk_rows) = fk_result {
				if !fk_rows.is_empty() {
					println!("\nForeign-key constraints:");
					for row in fk_rows {
						let constraint_name: String = row.get(0);
						let constraint_def: String = row.get(1);
						println!("    \"{}\" {}", constraint_name, constraint_def);
					}
				}
			}

			let check_result = if sameconn {
				ctx.client
					.query(check_constraints_query, &[&schema, &table_name])
					.await
			} else {
				match ctx.pool.get().await {
					Ok(client) => {
						client
							.query(check_constraints_query, &[&schema, &table_name])
							.await
					}
					Err(_) => {
						return ControlFlow::Continue(());
					}
				}
			};

			if let Ok(check_rows) = check_result {
				if !check_rows.is_empty() {
					println!("\nCheck constraints:");
					for row in check_rows {
						let constraint_name: String = row.get(0);
						let constraint_def: String = row.get(1);
						println!("    \"{}\" {}", constraint_name, constraint_def);
					}
				}
			}

			if detail {
				let info_result = if sameconn {
					ctx.client
						.query(table_info_query, &[&schema, &table_name])
						.await
				} else {
					match ctx.pool.get().await {
						Ok(client) => {
							client
								.query(table_info_query, &[&schema, &table_name])
								.await
						}
						Err(_) => {
							return ControlFlow::Continue(());
						}
					}
				};

				if let Ok(info_rows) = info_result {
					if let Some(row) = info_rows.first() {
						let owner: String = row.get(0);
						let size: String = row.get(1);
						let persistence: String = row.get(2);
						let table_comment: Option<String> = row.get(3);

						println!("\nOwner: {}", owner);
						println!("Size: {}", size);
						println!("Persistence: {}", persistence);
						if let Some(comment) = table_comment {
							if !comment.is_empty() {
								println!("Comment: {}", comment);
							}
						}
					}
				}
			}

			println!();
			ControlFlow::Continue(())
		}
		Err(e) => {
			eprintln!("Error describing table: {}", e);
			ControlFlow::Continue(())
		}
	}
}
